

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pycalphad.core.equilibrium &mdash; pycalphad 0.4+19.g9b7798b documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="pycalphad 0.4+19.g9b7798b documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> pycalphad
          

          
            
            <img src="../../../_static/logo.png" class="logo" />
          
          </a>

          
            
            
              <div class="version">
                0.4+19.g9b7798b
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../INSTALLING.html">Installation Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/modules.html">API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../CHANGES.html">What&#8217;s New</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../index.html">pycalphad</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      
    <li>pycalphad.core.equilibrium</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pycalphad.core.equilibrium</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The equilibrium module defines routines for interacting with</span>
<span class="sd">calculated phase equilibria.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">pycalphad.variables</span> <span class="k">as</span> <span class="nn">v</span>
<span class="kn">from</span> <span class="nn">pycalphad.core.utils</span> <span class="k">import</span> <span class="n">unpack_kwarg</span>
<span class="kn">from</span> <span class="nn">pycalphad.core.utils</span> <span class="k">import</span> <span class="n">sizeof_fmt</span>
<span class="kn">from</span> <span class="nn">pycalphad.core.utils</span> <span class="k">import</span> <span class="n">unpack_condition</span><span class="p">,</span> <span class="n">unpack_phases</span>
<span class="kn">from</span> <span class="nn">pycalphad</span> <span class="k">import</span> <span class="n">calculate</span><span class="p">,</span> <span class="n">Model</span>
<span class="kn">from</span> <span class="nn">pycalphad.constraints</span> <span class="k">import</span> <span class="n">mole_fraction</span>
<span class="kn">from</span> <span class="nn">pycalphad.core.lower_convex_hull</span> <span class="k">import</span> <span class="n">lower_convex_hull</span>
<span class="kn">from</span> <span class="nn">pycalphad.core.autograd_utils</span> <span class="k">import</span> <span class="n">build_functions</span> <span class="k">as</span> <span class="n">interpreted_build_functions</span>
<span class="kn">from</span> <span class="nn">pycalphad.core.sympydiff_utils</span> <span class="k">import</span> <span class="n">build_functions</span> <span class="k">as</span> <span class="n">compiled_build_functions</span>
<span class="kn">from</span> <span class="nn">pycalphad.core.tempfilemanager</span> <span class="k">import</span> <span class="n">TempfileManager</span>
<span class="kn">from</span> <span class="nn">pycalphad.core.constants</span> <span class="k">import</span> <span class="n">MIN_SITE_FRACTION</span><span class="p">,</span> <span class="n">COMP_DIFFERENCE_TOL</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="k">import</span> <span class="n">Add</span><span class="p">,</span> <span class="n">Symbol</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="k">import</span> <span class="n">tqdm</span> <span class="k">as</span> <span class="n">progressbar</span>
<span class="kn">import</span> <span class="nn">dask</span>
<span class="kn">import</span> <span class="nn">dask.multiprocessing</span><span class="o">,</span> <span class="nn">dask.async</span>
<span class="kn">from</span> <span class="nn">xarray</span> <span class="k">import</span> <span class="n">Dataset</span><span class="p">,</span> <span class="n">DataArray</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.spatial</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">namedtuple</span><span class="p">,</span> <span class="n">OrderedDict</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="k">import</span> <span class="n">datetime</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="c1"># Maximum number of multi-phase solver iterations</span>
<span class="n">MAX_SOLVE_ITERATIONS</span> <span class="o">=</span> <span class="mi">100</span>
<span class="c1"># Minimum energy (J/mol-atom) difference between iterations before stopping solver</span>
<span class="n">MIN_SOLVE_ENERGY_PROGRESS</span> <span class="o">=</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">6</span>
<span class="c1"># Maximum residual driving force (J/mol-atom) allowed for convergence</span>
<span class="n">MAX_SOLVE_DRIVING_FORCE</span> <span class="o">=</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">4</span>

<span class="n">PhaseRecord</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;PhaseRecord&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;variables&#39;</span><span class="p">,</span> <span class="s1">&#39;grad&#39;</span><span class="p">,</span> <span class="s1">&#39;hess&#39;</span><span class="p">,</span> <span class="s1">&#39;plane_grad&#39;</span><span class="p">,</span> <span class="s1">&#39;plane_hess&#39;</span><span class="p">,</span>
                                         <span class="s1">&#39;mass_obj&#39;</span><span class="p">,</span> <span class="s1">&#39;mass_grad&#39;</span><span class="p">,</span> <span class="s1">&#39;mass_hess&#39;</span><span class="p">])</span>

<div class="viewcode-block" id="EquilibriumError"><a class="viewcode-back" href="../../../api/pycalphad.core.html#pycalphad.core.equilibrium.EquilibriumError">[docs]</a><span class="k">class</span> <span class="nc">EquilibriumError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="s2">&quot;Exception related to calculation of equilibrium&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="ConditionError"><a class="viewcode-back" href="../../../api/pycalphad.core.html#pycalphad.core.equilibrium.ConditionError">[docs]</a><span class="k">class</span> <span class="nc">ConditionError</span><span class="p">(</span><span class="n">EquilibriumError</span><span class="p">):</span>
    <span class="s2">&quot;Exception related to equilibrium conditions&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="remove_degenerate_phases"><a class="viewcode-back" href="../../../api/pycalphad.core.html#pycalphad.core.equilibrium.remove_degenerate_phases">[docs]</a><span class="k">def</span> <span class="nf">remove_degenerate_phases</span><span class="p">(</span><span class="n">properties</span><span class="p">,</span> <span class="n">multi_index</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    For each phase pair with composition difference below tolerance,</span>
<span class="sd">    eliminate phase with largest index.</span>
<span class="sd">    Also remove phases with phase fractions close to zero.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    properties : xarray.Dataset</span>
<span class="sd">        Equilibrium calculation data. This will be modified!</span>
<span class="sd">    multi_index : tuple</span>
<span class="sd">        Index into &#39;properties&#39; of the condition set of interest.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">phases</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;Phase&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">multi_index</span><span class="p">])</span>
    <span class="c1"># Are there already removed phases?</span>
    <span class="k">if</span> <span class="s1">&#39;&#39;</span> <span class="ow">in</span> <span class="n">phases</span><span class="p">:</span>
        <span class="n">num_phases</span> <span class="o">=</span> <span class="n">phases</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">num_phases</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">phases</span><span class="p">)</span>
    <span class="n">phases</span> <span class="o">=</span> <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;Phase&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">multi_index</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[:</span><span class="n">num_phases</span><span class="p">]]</span>
    <span class="c1"># Group phases into multiple composition sets</span>
    <span class="n">phase_indices</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="nb">list</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">phase_idx</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">phases</span><span class="p">):</span>
        <span class="n">phase_indices</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">phase_idx</span><span class="p">)</span>
    <span class="c1"># Compute pairwise distances between compositions of like phases</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">phase_indices</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Phase is unique</span>
            <span class="k">continue</span>
        <span class="c1"># The reason we don&#39;t do this based on Y fractions is because</span>
        <span class="c1"># of sublattice symmetry. It&#39;s very easy to detect a &quot;miscibility gap&quot; which is actually</span>
        <span class="c1"># symmetry equivalent, i.e., D([A, B] - [B, A]) &gt; tol, but they are the same configuration.</span>
        <span class="n">comp_matrix</span> <span class="o">=</span> <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">multi_index</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[</span><span class="n">indices</span><span class="p">]]</span>
        <span class="n">comp_distances</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">squareform</span><span class="p">(</span><span class="n">scipy</span><span class="o">.</span><span class="n">spatial</span><span class="o">.</span><span class="n">distance</span><span class="o">.</span><span class="n">pdist</span><span class="p">(</span><span class="n">comp_matrix</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;chebyshev&#39;</span><span class="p">))</span>
        <span class="n">redundant_phases</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">redundant_phases</span> <span class="o">|=</span> <span class="p">{</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">comp_distances</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">COMP_DIFFERENCE_TOL</span><span class="p">:</span>
                    <span class="n">redundant_phases</span> <span class="o">|=</span> <span class="p">{</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="n">j</span><span class="p">]}</span>
        <span class="n">redundant_phases</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">redundant_phases</span><span class="p">)</span>
        <span class="n">kept_phase</span> <span class="o">=</span> <span class="n">redundant_phases</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">removed_phases</span> <span class="o">=</span> <span class="n">redundant_phases</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="c1"># Their NP values will be added to redundant_phases[0]</span>
        <span class="c1"># and they will be nulled out</span>
        <span class="k">for</span> <span class="n">redundant</span> <span class="ow">in</span> <span class="n">removed_phases</span><span class="p">:</span>
            <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;NP&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">multi_index</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[</span><span class="n">kept_phase</span><span class="p">]]</span> <span class="o">+=</span> \
                <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;NP&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">multi_index</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[</span><span class="n">redundant</span><span class="p">]]</span>
            <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;Phase&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">multi_index</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[</span><span class="n">redundant</span><span class="p">]]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="c1"># Eliminate any &#39;fake points&#39; that made it through the convex hull routine</span>
    <span class="c1"># These can show up from phases which aren&#39;t defined over all of composition space</span>
    <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;NP&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;Phase&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">==</span> <span class="s1">&#39;_FAKE_&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;Phase&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;Phase&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">==</span> <span class="s1">&#39;_FAKE_&#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="c1"># Delete unstable phases</span>
    <span class="n">unstable_phases</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;NP&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">multi_index</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">MIN_SITE_FRACTION</span><span class="p">)</span>
    <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;Phase&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">multi_index</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[</span><span class="n">unstable_phases</span><span class="p">]]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="c1"># Rewrite properties to delete all the nulled out phase entries</span>
    <span class="c1"># Then put them at the end</span>
    <span class="c1"># That will let us rewrite &#39;phases&#39; to have only the independent phases</span>
    <span class="c1"># And still preserve convenient indexing of &#39;properties&#39; with phase_idx</span>
    <span class="n">saved_indices</span> <span class="o">=</span> <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;Phase&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">multi_index</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span>
    <span class="n">saved_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">saved_indices</span><span class="p">))[</span><span class="n">saved_indices</span><span class="p">]</span>
    <span class="c1"># TODO: Assumes N=1 always</span>
    <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;NP&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">multi_index</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">saved_indices</span><span class="p">)]]</span> <span class="o">=</span> \
        <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;NP&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">multi_index</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[</span><span class="n">saved_indices</span><span class="p">]]</span> <span class="o">/</span> \
        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;NP&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">multi_index</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[</span><span class="n">saved_indices</span><span class="p">]])</span>
    <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;NP&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">multi_index</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">saved_indices</span><span class="p">):]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;Phase&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">multi_index</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">saved_indices</span><span class="p">)]]</span> <span class="o">=</span> \
        <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;Phase&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">multi_index</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[</span><span class="n">saved_indices</span><span class="p">]]</span>
    <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;Phase&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">multi_index</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">saved_indices</span><span class="p">):]]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">multi_index</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">saved_indices</span><span class="p">),</span> <span class="p">:]]</span> <span class="o">=</span> \
        <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">multi_index</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[</span><span class="n">saved_indices</span><span class="p">,</span> <span class="p">:]]</span>
    <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">multi_index</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">saved_indices</span><span class="p">):,</span> <span class="p">:]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">multi_index</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">saved_indices</span><span class="p">),</span> <span class="p">:]]</span> <span class="o">=</span> \
        <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">multi_index</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[</span><span class="n">saved_indices</span><span class="p">,</span> <span class="p">:]]</span>
    <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">multi_index</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">saved_indices</span><span class="p">):,</span> <span class="p">:]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span></div>


<span class="k">def</span> <span class="nf">_adjust_conditions</span><span class="p">(</span><span class="n">conds</span><span class="p">):</span>
    <span class="s2">&quot;Adjust conditions values to be within the numerical limit of the solver.&quot;</span>
    <span class="n">new_conds</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">conds</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">Composition</span><span class="p">):</span>
            <span class="n">new_conds</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">MIN_SITE_FRACTION</span><span class="o">*</span><span class="mi">1000</span><span class="p">)</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">unpack_condition</span><span class="p">(</span><span class="n">value</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_conds</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">unpack_condition</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_conds</span>

<span class="k">def</span> <span class="nf">_compute_phase_dof</span><span class="p">(</span><span class="n">dbf</span><span class="p">,</span> <span class="n">comps</span><span class="p">,</span> <span class="n">phases</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a list of the number of each phase&#39;s internal phase degrees of freedom.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">phase_dof</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">phases</span><span class="p">:</span>
        <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dbf</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">sublattices</span><span class="p">)):</span>
            <span class="n">active_in_subl</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dbf</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">constituents</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">comps</span><span class="p">)</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">active_in_subl</span><span class="p">)</span>
        <span class="n">phase_dof</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">total</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">phase_dof</span>

<span class="nd">@TempfileManager</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">())</span>
<span class="k">def</span> <span class="nf">_compute_constraints</span><span class="p">(</span><span class="n">dbf</span><span class="p">,</span> <span class="n">comps</span><span class="p">,</span> <span class="n">phases</span><span class="p">,</span> <span class="n">cur_conds</span><span class="p">,</span> <span class="n">site_fracs</span><span class="p">,</span> <span class="n">phase_fracs</span><span class="p">,</span> <span class="n">phase_records</span><span class="p">,</span> <span class="n">tmpman</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">l_multipliers</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chempots</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mole_fractions</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the constraint vector and constraint Jacobian matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num_sitefrac_bals</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">dbf</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sublattices</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">phases</span><span class="p">])</span>
    <span class="n">num_mass_bals</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cur_conds</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;X_&#39;</span><span class="p">)])</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">indep_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">cur_conds</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;X_&#39;</span><span class="p">)])</span>
    <span class="n">dependent_comp</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">comps</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">([</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cur_conds</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;X_&#39;</span><span class="p">)])</span> <span class="o">-</span> <span class="p">{</span><span class="s1">&#39;VA&#39;</span><span class="p">}</span>
    <span class="n">dependent_comp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dependent_comp</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">mole_fractions</span> <span class="o">=</span> <span class="n">mole_fractions</span> <span class="k">if</span> <span class="n">mole_fractions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">{}</span>
    <span class="n">num_constraints</span> <span class="o">=</span> <span class="n">num_sitefrac_bals</span> <span class="o">+</span> <span class="n">num_mass_bals</span>
    <span class="n">num_vars</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">site_fracs</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">phases</span><span class="p">)</span>
    <span class="n">phase_dof</span> <span class="o">=</span> <span class="n">_compute_phase_dof</span><span class="p">(</span><span class="n">dbf</span><span class="p">,</span> <span class="n">comps</span><span class="p">,</span> <span class="n">phases</span><span class="p">)</span>
    <span class="n">l_constraints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_constraints</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">l_multipliers</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">l_multipliers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_constraints</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">chempots</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">l_multipliers</span><span class="p">[</span><span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">dbf</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sublattices</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">phases</span><span class="p">]):</span>
                          <span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">dbf</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sublattices</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">phases</span><span class="p">])</span> <span class="o">+</span> <span class="n">num_mass_bals</span><span class="p">]</span> <span class="o">=</span> <span class="n">chempots</span>
    <span class="c1"># Convenience object for caller so it doesn&#39;t need to know about the constraint configuration</span>
    <span class="n">chemical_potentials</span> <span class="o">=</span> <span class="n">l_multipliers</span><span class="p">[</span><span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">dbf</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sublattices</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">phases</span><span class="p">]):</span>
        <span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">dbf</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sublattices</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">phases</span><span class="p">])</span> <span class="o">+</span> <span class="n">num_mass_bals</span><span class="p">]</span>

    <span class="n">constraint_jac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_constraints</span><span class="p">,</span> <span class="n">num_vars</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
    <span class="n">constraint_hess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_constraints</span><span class="p">,</span> <span class="n">num_vars</span><span class="p">,</span> <span class="n">num_vars</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
    <span class="n">contains_vacancies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">phases</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
    <span class="c1"># Ordering of constraints by row: sitefrac bal of each phase, then component mass balance</span>
    <span class="c1"># Ordering of constraints by column: site fractions of each phase, then phase fractions</span>
    <span class="c1"># First: Site fraction balance constraints</span>
    <span class="n">var_idx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">constraint_offset</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">phase_idx</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">phases</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dbf</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">sublattices</span><span class="p">)):</span>
            <span class="n">active_in_subl</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dbf</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">constituents</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">comps</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;VA&#39;</span> <span class="ow">in</span> <span class="n">active_in_subl</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">active_in_subl</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">contains_vacancies</span><span class="p">[</span><span class="n">phase_idx</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">constraint_jac</span><span class="p">[</span><span class="n">constraint_offset</span> <span class="o">+</span> <span class="n">idx</span><span class="p">,</span>
            <span class="n">var_idx</span><span class="p">:</span><span class="n">var_idx</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">active_in_subl</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="c1"># print(&#39;L_CONSTRAINTS[{}] = {}&#39;.format(constraint_offset+idx, (sum(site_fracs[var_idx:var_idx + len(active_in_subl)]) - 1)))</span>
            <span class="n">l_constraints</span><span class="p">[</span><span class="n">constraint_offset</span> <span class="o">+</span> <span class="n">idx</span><span class="p">]</span> <span class="o">=</span> \
                <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">site_fracs</span><span class="p">[</span><span class="n">var_idx</span><span class="p">:</span><span class="n">var_idx</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">active_in_subl</span><span class="p">)])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">var_idx</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">active_in_subl</span><span class="p">)</span>
        <span class="n">constraint_offset</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dbf</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">sublattices</span><span class="p">)</span>
    <span class="c1"># Second: Mass balance of each component</span>
    <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">comps</span> <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="s1">&#39;VA&#39;</span><span class="p">]:</span>
        <span class="n">var_offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">phase_idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">phase_frac</span><span class="p">,</span> <span class="n">con_vacs</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">phases</span><span class="p">,</span> <span class="n">phase_fracs</span><span class="p">,</span> <span class="n">contains_vacancies</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">mole_fractions</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">comp</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">mole_fractions</span><span class="p">[(</span><span class="n">name</span><span class="p">,</span> <span class="n">comp</span><span class="p">)]</span> <span class="o">=</span> <span class="n">interpreted_build_functions</span><span class="p">(</span><span class="n">mole_fraction</span><span class="p">(</span><span class="n">dbf</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">comps</span><span class="p">,</span> <span class="n">comp</span><span class="p">),</span>
                                                                        <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">phase_records</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span> <span class="o">-</span> <span class="p">{</span><span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">P</span><span class="p">},</span>
                                                                        <span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">),</span> <span class="n">tmpman</span><span class="o">=</span><span class="n">tmpman</span><span class="p">)</span>
            <span class="n">comp_obj</span><span class="p">,</span> <span class="n">comp_grad</span><span class="p">,</span> <span class="n">comp_hess</span> <span class="o">=</span> <span class="n">mole_fractions</span><span class="p">[(</span><span class="n">name</span><span class="p">,</span> <span class="n">comp</span><span class="p">)]</span>
            <span class="c1">#print(&#39;MOLE FRACTIONS&#39;, (name, comp))</span>
            <span class="c1"># current phase frac times the comp_grad</span>
            <span class="n">constraint_jac</span><span class="p">[</span><span class="n">constraint_offset</span><span class="p">,</span>
            <span class="n">var_offset</span><span class="p">:</span><span class="n">var_offset</span> <span class="o">+</span> <span class="n">phase_dof</span><span class="p">[</span><span class="n">phase_idx</span><span class="p">]]</span> <span class="o">=</span> \
                <span class="n">phase_frac</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">comp_grad</span><span class="p">(</span><span class="o">*</span><span class="n">site_fracs</span><span class="p">[</span><span class="n">var_offset</span><span class="p">:</span><span class="n">var_offset</span> <span class="o">+</span> <span class="n">phase_dof</span><span class="p">[</span><span class="n">phase_idx</span><span class="p">]]))</span>
            <span class="c1">#print(&#39;CONSTRAINT_JAC[{}] += {}&#39;.format((constraint_offset, slice(var_offset,var_offset + phase_dof[phase_idx])), phase_frac * np.squeeze(comp_grad(*site_fracs[var_offset:var_offset + phase_dof[phase_idx]]))))</span>
            <span class="n">constraint_jac</span><span class="p">[</span><span class="n">constraint_offset</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">site_fracs</span><span class="p">)</span> <span class="o">+</span> <span class="n">phase_idx</span><span class="p">]</span> <span class="o">+=</span> \
                <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">comp_obj</span><span class="p">(</span><span class="o">*</span><span class="n">site_fracs</span><span class="p">[</span><span class="n">var_offset</span><span class="p">:</span><span class="n">var_offset</span> <span class="o">+</span> <span class="n">phase_dof</span><span class="p">[</span><span class="n">phase_idx</span><span class="p">]]))</span>
            <span class="c1">#print(&#39;CONSTRAINT_JAC[{}] += {}&#39;.format((constraint_offset, len(site_fracs) + phase_idx), np.squeeze(comp_obj(*site_fracs[var_offset:var_offset + phase_dof[phase_idx]]))))</span>
            <span class="c1"># This term should only be non-zero for vacancy-containing sublattices</span>
            <span class="c1"># This check is to silence a warning about comp_hess() being zero</span>
            <span class="k">if</span> <span class="n">con_vacs</span><span class="p">:</span>
                <span class="n">constraint_hess</span><span class="p">[</span><span class="n">constraint_offset</span><span class="p">,</span>
                                <span class="n">var_offset</span><span class="p">:</span><span class="n">var_offset</span> <span class="o">+</span> <span class="n">phase_dof</span><span class="p">[</span><span class="n">phase_idx</span><span class="p">],</span>
                                <span class="n">var_offset</span><span class="p">:</span><span class="n">var_offset</span> <span class="o">+</span> <span class="n">phase_dof</span><span class="p">[</span><span class="n">phase_idx</span><span class="p">]]</span> <span class="o">=</span> \
                    <span class="n">phase_frac</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">comp_hess</span><span class="p">(</span><span class="o">*</span><span class="n">site_fracs</span><span class="p">[</span><span class="n">var_offset</span><span class="p">:</span><span class="n">var_offset</span> <span class="o">+</span> <span class="n">phase_dof</span><span class="p">[</span><span class="n">phase_idx</span><span class="p">]]))</span>
            <span class="n">constraint_hess</span><span class="p">[</span><span class="n">constraint_offset</span><span class="p">,</span>
            <span class="n">var_offset</span><span class="p">:</span><span class="n">var_offset</span> <span class="o">+</span> <span class="n">phase_dof</span><span class="p">[</span><span class="n">phase_idx</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">site_fracs</span><span class="p">)</span> <span class="o">+</span> <span class="n">phase_idx</span><span class="p">]</span> <span class="o">=</span> \
            <span class="n">constraint_hess</span><span class="p">[</span><span class="n">constraint_offset</span><span class="p">,</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">site_fracs</span><span class="p">)</span> <span class="o">+</span> <span class="n">phase_idx</span><span class="p">,</span> <span class="n">var_offset</span><span class="p">:</span><span class="n">var_offset</span> <span class="o">+</span> <span class="n">phase_dof</span><span class="p">[</span><span class="n">phase_idx</span><span class="p">]]</span> <span class="o">=</span> \
                <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">comp_grad</span><span class="p">(</span><span class="o">*</span><span class="n">site_fracs</span><span class="p">[</span><span class="n">var_offset</span><span class="p">:</span><span class="n">var_offset</span> <span class="o">+</span> <span class="n">phase_dof</span><span class="p">[</span><span class="n">phase_idx</span><span class="p">]]))</span>
            <span class="n">l_constraints</span><span class="p">[</span><span class="n">constraint_offset</span><span class="p">]</span> <span class="o">+=</span> \
                <span class="n">phase_frac</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">comp_obj</span><span class="p">(</span><span class="o">*</span><span class="n">site_fracs</span><span class="p">[</span><span class="n">var_offset</span><span class="p">:</span><span class="n">var_offset</span> <span class="o">+</span> <span class="n">phase_dof</span><span class="p">[</span><span class="n">phase_idx</span><span class="p">]]))</span>
            <span class="c1">#print(&#39;L_CONSTRAINTS[{}] += {}&#39;.format(constraint_offset, phase_frac * np.squeeze(comp_obj(*site_fracs[var_offset:var_offset+phase_dof[phase_idx]]))))</span>
            <span class="n">var_offset</span> <span class="o">+=</span> <span class="n">phase_dof</span><span class="p">[</span><span class="n">phase_idx</span><span class="p">]</span>
            <span class="n">phase_idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">comp</span> <span class="o">!=</span> <span class="n">dependent_comp</span><span class="p">:</span>
            <span class="n">l_constraints</span><span class="p">[</span><span class="n">constraint_offset</span><span class="p">]</span> <span class="o">-=</span> <span class="nb">float</span><span class="p">(</span><span class="n">cur_conds</span><span class="p">[</span><span class="s1">&#39;X_&#39;</span> <span class="o">+</span> <span class="n">comp</span><span class="p">])</span>
            <span class="c1">#print(&#39;L_CONSTRAINTS[{}] -= {}&#39;.format(constraint_offset, float(cur_conds[&#39;X_&#39;+comp])))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO: Assuming N=1 (fixed for dependent component)</span>
            <span class="n">l_constraints</span><span class="p">[</span><span class="n">constraint_offset</span><span class="p">]</span> <span class="o">-=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">indep_sum</span><span class="p">)</span>
            <span class="c1">#print(&#39;L_CONSTRAINTS[{}] -= {}&#39;.format(constraint_offset, (1-indep_sum)))</span>
        <span class="c1">#l_constraints[constraint_offset] *= -1</span>
        <span class="c1"># print(&#39;L_CONSTRAINTS[{}] *= -1&#39;.format(constraint_offset))</span>
        <span class="n">constraint_offset</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1">#print(&#39;L_CONSTRAINTS&#39;, l_constraints)</span>
    <span class="k">return</span> <span class="n">l_constraints</span><span class="p">,</span> <span class="n">constraint_jac</span><span class="p">,</span> <span class="n">constraint_hess</span><span class="p">,</span> <span class="n">l_multipliers</span><span class="p">,</span> <span class="n">chemical_potentials</span><span class="p">,</span> <span class="n">mole_fractions</span>

<span class="k">def</span> <span class="nf">_compute_multiphase_objective</span><span class="p">(</span><span class="n">dbf</span><span class="p">,</span> <span class="n">comps</span><span class="p">,</span> <span class="n">phases</span><span class="p">,</span> <span class="n">cur_conds</span><span class="p">,</span> <span class="n">site_fracs</span><span class="p">,</span> <span class="n">phase_fracs</span><span class="p">,</span> <span class="n">callable_dict</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">phase_dof</span> <span class="o">=</span> <span class="n">_compute_phase_dof</span><span class="p">(</span><span class="n">dbf</span><span class="p">,</span> <span class="n">comps</span><span class="p">,</span> <span class="n">phases</span><span class="p">)</span>
    <span class="n">var_offset</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">phase_idx</span><span class="p">,</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">phase_frac</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">phases</span><span class="p">,</span> <span class="n">phase_fracs</span><span class="p">)):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">callable_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="n">obj_res</span> <span class="o">=</span> <span class="n">obj</span><span class="p">(</span><span class="o">*</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">([</span><span class="n">cur_conds</span><span class="p">[</span><span class="s1">&#39;P&#39;</span><span class="p">],</span> <span class="n">cur_conds</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]],</span>
                                       <span class="n">site_fracs</span><span class="p">[</span><span class="n">var_offset</span><span class="p">:</span><span class="n">var_offset</span> <span class="o">+</span> <span class="n">phase_dof</span><span class="p">[</span><span class="n">phase_idx</span><span class="p">]])</span>
                      <span class="p">)</span>
        <span class="n">result</span> <span class="o">+=</span> <span class="n">phase_frac</span> <span class="o">*</span> <span class="n">obj_res</span>
        <span class="n">var_offset</span> <span class="o">+=</span> <span class="n">phase_dof</span><span class="p">[</span><span class="n">phase_idx</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="k">def</span> <span class="nf">_build_multiphase_gradient</span><span class="p">(</span><span class="n">dbf</span><span class="p">,</span> <span class="n">comps</span><span class="p">,</span> <span class="n">phases</span><span class="p">,</span> <span class="n">cur_conds</span><span class="p">,</span> <span class="n">site_fracs</span><span class="p">,</span> <span class="n">phase_fracs</span><span class="p">,</span>
                               <span class="n">l_constraints</span><span class="p">,</span> <span class="n">constraint_jac</span><span class="p">,</span> <span class="n">l_multipliers</span><span class="p">,</span> <span class="n">callable_dict</span><span class="p">,</span> <span class="n">phase_records</span><span class="p">):</span>
    <span class="n">var_offset</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">phase_idx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">phase_dof</span> <span class="o">=</span> <span class="n">_compute_phase_dof</span><span class="p">(</span><span class="n">dbf</span><span class="p">,</span> <span class="n">comps</span><span class="p">,</span> <span class="n">phases</span><span class="p">)</span>
    <span class="n">num_vars</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">site_fracs</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">phases</span><span class="p">)</span>
    <span class="n">gradient_term</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_vars</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">phase_frac</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">phases</span><span class="p">,</span> <span class="n">phase_fracs</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">callable_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="n">grad</span> <span class="o">=</span> <span class="n">phase_records</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">grad</span>
        <span class="n">obj_res</span> <span class="o">=</span> <span class="n">obj</span><span class="p">(</span><span class="o">*</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">([</span><span class="n">cur_conds</span><span class="p">[</span><span class="s1">&#39;P&#39;</span><span class="p">],</span> <span class="n">cur_conds</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]],</span>
                                       <span class="n">site_fracs</span><span class="p">[</span><span class="n">var_offset</span><span class="p">:</span><span class="n">var_offset</span> <span class="o">+</span> <span class="n">phase_dof</span><span class="p">[</span><span class="n">phase_idx</span><span class="p">]])</span>
                      <span class="p">)</span>
        <span class="n">grad_res</span> <span class="o">=</span> <span class="n">grad</span><span class="p">(</span><span class="o">*</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">([</span><span class="n">cur_conds</span><span class="p">[</span><span class="s1">&#39;P&#39;</span><span class="p">],</span> <span class="n">cur_conds</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]],</span>
                                         <span class="n">site_fracs</span><span class="p">[</span><span class="n">var_offset</span><span class="p">:</span><span class="n">var_offset</span> <span class="o">+</span> <span class="n">phase_dof</span><span class="p">[</span><span class="n">phase_idx</span><span class="p">]])</span>
                        <span class="p">)</span>
        <span class="n">gradient_term</span><span class="p">[</span><span class="n">var_offset</span><span class="p">:</span><span class="n">var_offset</span> <span class="o">+</span> <span class="n">phase_dof</span><span class="p">[</span><span class="n">phase_idx</span><span class="p">]]</span> <span class="o">=</span> \
            <span class="n">phase_frac</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">grad_res</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]</span>  <span class="c1"># Remove P,T grad part</span>
        <span class="n">gradient_term</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">site_fracs</span><span class="p">)</span> <span class="o">+</span> <span class="n">phase_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj_res</span>
        <span class="n">var_offset</span> <span class="o">+=</span> <span class="n">phase_dof</span><span class="p">[</span><span class="n">phase_idx</span><span class="p">]</span>
        <span class="n">phase_idx</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">gradient_term</span>

<span class="k">def</span> <span class="nf">_build_multiphase_system</span><span class="p">(</span><span class="n">dbf</span><span class="p">,</span> <span class="n">comps</span><span class="p">,</span> <span class="n">phases</span><span class="p">,</span> <span class="n">cur_conds</span><span class="p">,</span> <span class="n">site_fracs</span><span class="p">,</span> <span class="n">phase_fracs</span><span class="p">,</span>
                             <span class="n">l_constraints</span><span class="p">,</span> <span class="n">constraint_jac</span><span class="p">,</span> <span class="n">constraint_hess</span><span class="p">,</span> <span class="n">l_multipliers</span><span class="p">,</span>
                             <span class="n">callable_dict</span><span class="p">,</span> <span class="n">phase_records</span><span class="p">):</span>
    <span class="c1"># Now build objective Hessian and gradient terms</span>
    <span class="n">var_offset</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">phase_idx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">phase_dof</span> <span class="o">=</span> <span class="n">_compute_phase_dof</span><span class="p">(</span><span class="n">dbf</span><span class="p">,</span> <span class="n">comps</span><span class="p">,</span> <span class="n">phases</span><span class="p">)</span>
    <span class="n">num_vars</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">site_fracs</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">phases</span><span class="p">)</span>
    <span class="n">l_hessian</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_vars</span><span class="p">,</span> <span class="n">num_vars</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
    <span class="n">gradient_term</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_vars</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">phase_frac</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">phases</span><span class="p">,</span> <span class="n">phase_fracs</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">callable_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="n">hess</span> <span class="o">=</span> <span class="n">phase_records</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">hess</span>
        <span class="n">grad</span> <span class="o">=</span> <span class="n">phase_records</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">grad</span>
        <span class="n">obj_res</span> <span class="o">=</span> <span class="n">obj</span><span class="p">(</span><span class="o">*</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">([</span><span class="n">cur_conds</span><span class="p">[</span><span class="s1">&#39;P&#39;</span><span class="p">],</span> <span class="n">cur_conds</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]],</span>
                                       <span class="n">site_fracs</span><span class="p">[</span><span class="n">var_offset</span><span class="p">:</span><span class="n">var_offset</span> <span class="o">+</span> <span class="n">phase_dof</span><span class="p">[</span><span class="n">phase_idx</span><span class="p">]])</span>
                      <span class="p">)</span>
        <span class="n">grad_res</span> <span class="o">=</span> <span class="n">grad</span><span class="p">(</span><span class="o">*</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">([</span><span class="n">cur_conds</span><span class="p">[</span><span class="s1">&#39;P&#39;</span><span class="p">],</span> <span class="n">cur_conds</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]],</span>
                                         <span class="n">site_fracs</span><span class="p">[</span><span class="n">var_offset</span><span class="p">:</span><span class="n">var_offset</span> <span class="o">+</span> <span class="n">phase_dof</span><span class="p">[</span><span class="n">phase_idx</span><span class="p">]])</span>
                        <span class="p">)</span>
        <span class="n">gradient_term</span><span class="p">[</span><span class="n">var_offset</span><span class="p">:</span><span class="n">var_offset</span> <span class="o">+</span> <span class="n">phase_dof</span><span class="p">[</span><span class="n">phase_idx</span><span class="p">]]</span> <span class="o">=</span> \
            <span class="n">phase_frac</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">grad_res</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]</span>  <span class="c1"># Remove P,T grad part</span>
        <span class="n">gradient_term</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">site_fracs</span><span class="p">)</span> <span class="o">+</span> <span class="n">phase_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj_res</span>
        <span class="n">l_hessian</span><span class="p">[</span><span class="n">var_offset</span><span class="p">:</span><span class="n">var_offset</span> <span class="o">+</span> <span class="n">phase_dof</span><span class="p">[</span><span class="n">phase_idx</span><span class="p">],</span>
        <span class="n">var_offset</span><span class="p">:</span><span class="n">var_offset</span> <span class="o">+</span> <span class="n">phase_dof</span><span class="p">[</span><span class="n">phase_idx</span><span class="p">]]</span> <span class="o">=</span> \
            <span class="n">phase_frac</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">hess</span><span class="p">(</span><span class="o">*</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">([</span><span class="n">cur_conds</span><span class="p">[</span><span class="s1">&#39;P&#39;</span><span class="p">],</span> <span class="n">cur_conds</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]],</span>
                                                          <span class="n">site_fracs</span><span class="p">[</span><span class="n">var_offset</span><span class="p">:</span><span class="n">var_offset</span> <span class="o">+</span> <span class="n">phase_dof</span><span class="p">[</span><span class="n">phase_idx</span><span class="p">]])</span>
                                         <span class="p">))[</span><span class="mi">2</span><span class="p">:,</span> <span class="mi">2</span><span class="p">:]</span>  <span class="c1"># Remove P,T hessian part</span>
        <span class="c1"># Phase fraction / site fraction cross derivative</span>
        <span class="n">l_hessian</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">site_fracs</span><span class="p">)</span> <span class="o">+</span> <span class="n">phase_idx</span><span class="p">,</span> <span class="n">var_offset</span><span class="p">:</span><span class="n">var_offset</span> <span class="o">+</span> <span class="n">phase_dof</span><span class="p">[</span><span class="n">phase_idx</span><span class="p">]]</span> <span class="o">=</span> \
            <span class="n">l_hessian</span><span class="p">[</span><span class="n">var_offset</span><span class="p">:</span><span class="n">var_offset</span> <span class="o">+</span> <span class="n">phase_dof</span><span class="p">[</span><span class="n">phase_idx</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">site_fracs</span><span class="p">)</span> <span class="o">+</span> <span class="n">phase_idx</span><span class="p">]</span> <span class="o">=</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">grad_res</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]</span> <span class="c1"># Remove P,T grad part</span>
        <span class="n">var_offset</span> <span class="o">+=</span> <span class="n">phase_dof</span><span class="p">[</span><span class="n">phase_idx</span><span class="p">]</span>
        <span class="n">phase_idx</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1"># Constraint contribution to the Hessian (some constraints like mass balance are nonlinear)</span>
    <span class="n">l_hessian</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">l_multipliers</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">constraint_hess</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">l_hessian</span><span class="p">,</span> <span class="n">gradient_term</span>

<span class="nd">@TempfileManager</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">())</span>
<span class="k">def</span> <span class="nf">_solve_eq_at_conditions</span><span class="p">(</span><span class="n">dbf</span><span class="p">,</span> <span class="n">comps</span><span class="p">,</span> <span class="n">properties</span><span class="p">,</span> <span class="n">phase_records</span><span class="p">,</span> <span class="n">callable_dict</span><span class="p">,</span> <span class="n">verbose</span><span class="p">,</span> <span class="n">tmpman</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute equilibrium for the given conditions.</span>
<span class="sd">    This private function is meant to be called from a worker subprocess.</span>
<span class="sd">    For that case, usually only a small slice of the master &#39;properties&#39; is provided.</span>
<span class="sd">    Since that slice will be copied, we also return the modified &#39;properties&#39;.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dbf : Database</span>
<span class="sd">        Thermodynamic database containing the relevant parameters.</span>
<span class="sd">    comps : list</span>
<span class="sd">        Names of components to consider in the calculation.</span>
<span class="sd">    properties : Dataset</span>
<span class="sd">        Will be modified! Thermodynamic properties and conditions.</span>
<span class="sd">    phase_records : dict of PhaseRecord</span>
<span class="sd">        Details on phase callables.</span>
<span class="sd">    callable_dict : dict of callable</span>
<span class="sd">        Objective functions for each phase.</span>
<span class="sd">    verbose : bool</span>
<span class="sd">        Print details.</span>
<span class="sd">    tmpman : TempfileManager</span>
<span class="sd">        Temporary file context manager.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    properties : Dataset</span>
<span class="sd">        Modified with equilibrium values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">it</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nditer</span><span class="p">(</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;GM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;multi_index&#39;</span><span class="p">])</span>
    <span class="c1">#if verbose:</span>
    <span class="c1">#    print(&#39;INITIAL CONFIGURATION&#39;)</span>
    <span class="c1">#    print(properties.MU)</span>
    <span class="c1">#    print(properties.Phase)</span>
    <span class="c1">#    print(properties.NP)</span>
    <span class="c1">#    print(properties.X)</span>
    <span class="c1">#    print(properties.Y)</span>
    <span class="c1">#    print(&#39;---------------------&#39;)</span>
    <span class="k">while</span> <span class="ow">not</span> <span class="n">it</span><span class="o">.</span><span class="n">finished</span><span class="p">:</span>
        <span class="c1"># A lot of this code relies on cur_conds being ordered!</span>
        <span class="n">cur_conds</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;GM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span>
                                    <span class="p">[</span><span class="n">b</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">,</span> <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;GM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">values</span><span class="p">())]))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cur_conds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">cur_conds</span> <span class="o">=</span> <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;GM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">coords</span>
        <span class="c1"># sum of independently specified components</span>
        <span class="n">indep_sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">cur_conds</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;X_&#39;</span><span class="p">)])</span>
        <span class="k">if</span> <span class="n">indep_sum</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Sum of independent component mole fractions greater than one</span>
            <span class="c1"># Skip this condition set</span>
            <span class="c1"># We silently allow this to make 2-D composition mapping easier</span>
            <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;MU&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;NP&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">phases</span><span class="p">)]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;Phase&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">phases</span><span class="p">)]]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">phases</span><span class="p">)]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;GM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">it</span><span class="o">.</span><span class="n">iternext</span><span class="p">()</span>
            <span class="k">continue</span>
        <span class="n">dependent_comp</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">comps</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">([</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cur_conds</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;X_&#39;</span><span class="p">)])</span> <span class="o">-</span> <span class="p">{</span><span class="s1">&#39;VA&#39;</span><span class="p">}</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dependent_comp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">dependent_comp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dependent_comp</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Number of dependent components different from one&#39;</span><span class="p">)</span>
        <span class="c1"># chem_pots = OrderedDict(zip(properties.coords[&#39;component&#39;].values, properties[&#39;MU&#39;].values[it.multi_index]))</span>
        <span class="c1"># Used to cache generated mole fraction functions</span>
        <span class="n">mole_fractions</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">cur_iter</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">MAX_SOLVE_ITERATIONS</span><span class="p">):</span>
            <span class="c1"># print(&#39;CUR_ITER:&#39;, cur_iter)</span>
            <span class="n">phases</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;Phase&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">])</span>
            <span class="k">if</span> <span class="s1">&#39;&#39;</span> <span class="ow">in</span> <span class="n">phases</span><span class="p">:</span>
                <span class="n">old_phase_length</span> <span class="o">=</span> <span class="n">phases</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">old_phase_length</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">remove_degenerate_phases</span><span class="p">(</span><span class="n">properties</span><span class="p">,</span> <span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">)</span>
            <span class="n">phases</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;Phase&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">])</span>
            <span class="k">if</span> <span class="s1">&#39;&#39;</span> <span class="ow">in</span> <span class="n">phases</span><span class="p">:</span>
                <span class="n">new_phase_length</span> <span class="o">=</span> <span class="n">phases</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_phase_length</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="c1"># Are there removed phases?</span>
            <span class="k">if</span> <span class="s1">&#39;&#39;</span> <span class="ow">in</span> <span class="n">phases</span><span class="p">:</span>
                <span class="n">num_phases</span> <span class="o">=</span> <span class="n">phases</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">num_phases</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">phases</span><span class="p">)</span>
            <span class="n">zero_dof</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
                <span class="p">(</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">]</span> <span class="o">==</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">]))</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">num_phases</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">zero_dof</span><span class="p">:</span>
                <span class="c1"># Single phase with zero internal degrees of freedom, can&#39;t do any refinement</span>
                <span class="c1"># TODO: In the future we may be able to refine other degrees of freedom like temperature</span>
                <span class="c1"># Chemical potentials have no meaning for this case</span>
                <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;MU&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">break</span>
            <span class="n">phases</span> <span class="o">=</span> <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;Phase&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[:</span><span class="n">num_phases</span><span class="p">]]</span>
            <span class="c1"># num_sitefrac_bals = sum([len(dbf.phases[i].sublattices) for i in phases])</span>
            <span class="c1"># num_mass_bals = len([i for i in cur_conds.keys() if i.startswith(&#39;X_&#39;)]) + 1</span>
            <span class="n">phase_fracs</span> <span class="o">=</span> <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;NP&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">phases</span><span class="p">)]]</span>
            <span class="n">phase_dof</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">phase_records</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span> <span class="o">-</span> <span class="p">{</span><span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">P</span><span class="p">})</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">phases</span><span class="p">]</span>
            <span class="c1"># Flatten site fractions array and remove nan padding</span>
            <span class="n">site_fracs</span> <span class="o">=</span> <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="c1"># That *should* give us the internal dof</span>
            <span class="c1"># This may break if non-padding nan&#39;s slipped in from elsewhere...</span>
            <span class="n">site_fracs</span> <span class="o">=</span> <span class="n">site_fracs</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">site_fracs</span><span class="p">)]</span>
            <span class="n">site_fracs</span><span class="p">[</span><span class="n">site_fracs</span> <span class="o">&lt;</span> <span class="n">MIN_SITE_FRACTION</span><span class="p">]</span> <span class="o">=</span> <span class="n">MIN_SITE_FRACTION</span>
            <span class="n">phase_fracs</span><span class="p">[</span><span class="n">phase_fracs</span> <span class="o">&lt;</span> <span class="n">MIN_SITE_FRACTION</span><span class="p">]</span> <span class="o">=</span> <span class="n">MIN_SITE_FRACTION</span>
            <span class="n">var_idx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">phases</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dbf</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">sublattices</span><span class="p">)):</span>
                    <span class="n">active_in_subl</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">dbf</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">constituents</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">comps</span><span class="p">)</span>
                    <span class="n">site_fracs</span><span class="p">[</span><span class="n">var_idx</span><span class="p">:</span><span class="n">var_idx</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">active_in_subl</span><span class="p">)]</span> <span class="o">/=</span> \
                        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">site_fracs</span><span class="p">[</span><span class="n">var_idx</span><span class="p">:</span><span class="n">var_idx</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">active_in_subl</span><span class="p">)],</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">var_idx</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">active_in_subl</span><span class="p">)</span>
            <span class="c1"># Reset Lagrange multipliers if active set of phases change</span>
            <span class="k">if</span> <span class="n">cur_iter</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">old_phase_length</span> <span class="o">!=</span> <span class="n">new_phase_length</span><span class="p">):</span>
                <span class="n">l_multipliers</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="n">l_constraints</span><span class="p">,</span> <span class="n">constraint_jac</span><span class="p">,</span> <span class="n">constraint_hess</span><span class="p">,</span> <span class="n">l_multipliers</span><span class="p">,</span> <span class="n">old_chem_pots</span><span class="p">,</span> <span class="n">mole_fraction_funcs</span> <span class="o">=</span> \
                <span class="n">_compute_constraints</span><span class="p">(</span><span class="n">dbf</span><span class="p">,</span> <span class="n">comps</span><span class="p">,</span> <span class="n">phases</span><span class="p">,</span> <span class="n">cur_conds</span><span class="p">,</span> <span class="n">site_fracs</span><span class="p">,</span> <span class="n">phase_fracs</span><span class="p">,</span> <span class="n">phase_records</span><span class="p">,</span>
                                     <span class="n">tmpman</span><span class="o">=</span><span class="n">tmpman</span><span class="p">,</span> <span class="n">l_multipliers</span><span class="o">=</span><span class="n">l_multipliers</span><span class="p">,</span>
                                     <span class="n">chempots</span><span class="o">=</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;MU&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">],</span> <span class="n">mole_fractions</span><span class="o">=</span><span class="n">mole_fractions</span><span class="p">)</span>
            <span class="n">qmat</span><span class="p">,</span> <span class="n">rmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">qr</span><span class="p">(</span><span class="n">constraint_jac</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;complete&#39;</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">rmat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">qmat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Construct orthonormal basis for the constraints</span>
            <span class="n">ymat</span> <span class="o">=</span> <span class="n">qmat</span><span class="p">[:,</span> <span class="p">:</span><span class="n">m</span><span class="p">]</span>
            <span class="n">zmat</span> <span class="o">=</span> <span class="n">qmat</span><span class="p">[:,</span> <span class="n">m</span><span class="p">:]</span>
            <span class="c1"># Equation 18.14a in Nocedal and Wright</span>
            <span class="n">p_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">constraint_jac</span><span class="p">,</span> <span class="n">ymat</span><span class="p">),</span> <span class="o">-</span><span class="n">l_constraints</span><span class="p">)</span>
            <span class="n">num_vars</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">site_fracs</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">phases</span><span class="p">)</span>
            <span class="n">l_hessian</span><span class="p">,</span> <span class="n">gradient_term</span> <span class="o">=</span> <span class="n">_build_multiphase_system</span><span class="p">(</span><span class="n">dbf</span><span class="p">,</span> <span class="n">comps</span><span class="p">,</span> <span class="n">phases</span><span class="p">,</span> <span class="n">cur_conds</span><span class="p">,</span> <span class="n">site_fracs</span><span class="p">,</span> <span class="n">phase_fracs</span><span class="p">,</span>
                                                                <span class="n">l_constraints</span><span class="p">,</span> <span class="n">constraint_jac</span><span class="p">,</span> <span class="n">constraint_hess</span><span class="p">,</span>
                                                                <span class="n">l_multipliers</span><span class="p">,</span> <span class="n">callable_dict</span><span class="p">,</span> <span class="n">phase_records</span><span class="p">)</span>
            <span class="c1"># Equation 18.18 in Nocedal and Wright</span>
            <span class="k">if</span> <span class="n">m</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                     <span class="n">p_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">zmat</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">l_hessian</span><span class="p">),</span> <span class="n">zmat</span><span class="p">),</span>
                                           <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">zmat</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">l_hessian</span><span class="p">),</span> <span class="n">ymat</span><span class="p">),</span> <span class="n">p_y</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">zmat</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">gradient_term</span><span class="p">))</span>
                <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
                    <span class="n">p_z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">zmat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">zmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">p_z</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">step</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ymat</span><span class="p">,</span> <span class="n">p_y</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">zmat</span><span class="p">,</span> <span class="n">p_z</span><span class="p">)</span>
            <span class="n">old_energy</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;GM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">])</span>
            <span class="n">old_chem_pots</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;MU&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">])</span>
            <span class="n">candidate_site_fracs</span> <span class="o">=</span> <span class="n">site_fracs</span> <span class="o">+</span> <span class="n">step</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">site_fracs</span><span class="p">)]</span>
            <span class="n">candidate_site_fracs</span><span class="p">[</span><span class="n">candidate_site_fracs</span> <span class="o">&lt;</span> <span class="n">MIN_SITE_FRACTION</span><span class="p">]</span> <span class="o">=</span> <span class="n">MIN_SITE_FRACTION</span>
            <span class="n">candidate_site_fracs</span><span class="p">[</span><span class="n">candidate_site_fracs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">candidate_phase_fracs</span> <span class="o">=</span> <span class="n">phase_fracs</span> <span class="o">+</span> \
                                    <span class="n">step</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">candidate_site_fracs</span><span class="p">):</span><span class="nb">len</span><span class="p">(</span><span class="n">candidate_site_fracs</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">phases</span><span class="p">)]</span>
            <span class="n">candidate_phase_fracs</span><span class="p">[</span><span class="n">candidate_phase_fracs</span> <span class="o">&lt;</span> <span class="n">MIN_SITE_FRACTION</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">candidate_phase_fracs</span><span class="p">[</span><span class="n">candidate_phase_fracs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="p">(</span><span class="n">candidate_l_constraints</span><span class="p">,</span> <span class="n">candidate_constraint_jac</span><span class="p">,</span> <span class="n">candidate_constraint_hess</span><span class="p">,</span>
             <span class="n">candidate_l_multipliers</span><span class="p">,</span> <span class="n">candidate_chem_pots</span><span class="p">,</span> <span class="n">mole_fraction_funcs</span><span class="p">)</span> <span class="o">=</span> \
                <span class="n">_compute_constraints</span><span class="p">(</span><span class="n">dbf</span><span class="p">,</span> <span class="n">comps</span><span class="p">,</span> <span class="n">phases</span><span class="p">,</span> <span class="n">cur_conds</span><span class="p">,</span>
                                     <span class="n">candidate_site_fracs</span><span class="p">,</span> <span class="n">candidate_phase_fracs</span><span class="p">,</span> <span class="n">phase_records</span><span class="p">,</span> <span class="n">tmpman</span><span class="o">=</span><span class="n">tmpman</span><span class="p">,</span>
                                     <span class="n">l_multipliers</span><span class="o">=</span><span class="n">l_multipliers</span><span class="p">,</span> <span class="n">mole_fractions</span><span class="o">=</span><span class="n">mole_fractions</span><span class="p">)</span>
            <span class="n">candidate_gradient_term</span> <span class="o">=</span> <span class="n">_build_multiphase_gradient</span><span class="p">(</span><span class="n">dbf</span><span class="p">,</span> <span class="n">comps</span><span class="p">,</span> <span class="n">phases</span><span class="p">,</span>
                                                                 <span class="n">cur_conds</span><span class="p">,</span> <span class="n">candidate_site_fracs</span><span class="p">,</span>
                                                                 <span class="n">candidate_phase_fracs</span><span class="p">,</span>
                                                                 <span class="n">candidate_l_constraints</span><span class="p">,</span> <span class="n">candidate_constraint_jac</span><span class="p">,</span>
                                                                 <span class="n">candidate_l_multipliers</span><span class="p">,</span> <span class="n">callable_dict</span><span class="p">,</span> <span class="n">phase_records</span><span class="p">)</span>
            <span class="n">candidate_energy</span> <span class="o">=</span> <span class="n">_compute_multiphase_objective</span><span class="p">(</span><span class="n">dbf</span><span class="p">,</span> <span class="n">comps</span><span class="p">,</span> <span class="n">phases</span><span class="p">,</span> <span class="n">cur_conds</span><span class="p">,</span> <span class="n">candidate_site_fracs</span><span class="p">,</span>
                                                             <span class="n">candidate_phase_fracs</span><span class="p">,</span>
                                                             <span class="n">callable_dict</span><span class="p">)</span>
            <span class="c1"># We updated degrees of freedom this iteration</span>
            <span class="n">new_l_multipliers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">constraint_jac</span><span class="p">,</span> <span class="n">ymat</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                                <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ymat</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">gradient_term</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">l_hessian</span><span class="p">,</span> <span class="n">step</span><span class="p">)))</span>
            <span class="c1"># XXX: Should fix underlying numerical problem at edges of composition space instead of working around</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">new_l_multipliers</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">new_l_multipliers</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="n">e10</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WARNING: Unstable Lagrange multipliers: &#39;</span><span class="p">,</span> <span class="n">new_l_multipliers</span><span class="p">)</span>
                <span class="c1"># Equation 18.16 in Nocedal and Wright</span>
                <span class="c1"># This method is less accurate but more stable</span>
                <span class="n">new_l_multipliers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">candidate_constraint_jac</span><span class="p">,</span>
                                                                       <span class="n">candidate_constraint_jac</span><span class="o">.</span><span class="n">T</span><span class="p">)),</span>
                                           <span class="n">candidate_constraint_jac</span><span class="p">),</span> <span class="n">candidate_gradient_term</span><span class="p">)</span>
            <span class="n">l_multipliers</span> <span class="o">=</span> <span class="n">new_l_multipliers</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;NEW_L_MULTIPLIERS&#39;</span><span class="p">,</span> <span class="n">l_multipliers</span><span class="p">)</span>
            <span class="n">num_mass_bals</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cur_conds</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;X_&#39;</span><span class="p">)])</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">chemical_potentials</span> <span class="o">=</span> <span class="n">l_multipliers</span><span class="p">[</span><span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">dbf</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sublattices</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">phases</span><span class="p">]):</span>
                                                <span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">dbf</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sublattices</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">phases</span><span class="p">])</span> <span class="o">+</span> <span class="n">num_mass_bals</span><span class="p">]</span>
            <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;MU&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">chemical_potentials</span>
            <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;NP&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">phases</span><span class="p">)]]</span> <span class="o">=</span> <span class="n">candidate_phase_fracs</span>
            <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">phases</span><span class="p">)]]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;GM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">candidate_energy</span>
            <span class="n">var_offset</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">phase_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">phases</span><span class="p">)):</span>
                <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[</span><span class="n">phase_idx</span><span class="p">,</span> <span class="p">:</span><span class="n">phase_dof</span><span class="p">[</span><span class="n">phase_idx</span><span class="p">]]]</span> <span class="o">=</span> \
                    <span class="n">candidate_site_fracs</span><span class="p">[</span><span class="n">var_offset</span><span class="p">:</span><span class="n">var_offset</span> <span class="o">+</span> <span class="n">phase_dof</span><span class="p">[</span><span class="n">phase_idx</span><span class="p">]]</span>
                <span class="k">for</span> <span class="n">comp_idx</span><span class="p">,</span> <span class="n">comp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">comps</span> <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="s1">&#39;VA&#39;</span><span class="p">]):</span>
                    <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[</span><span class="n">phase_idx</span><span class="p">,</span> <span class="n">comp_idx</span><span class="p">]]</span> <span class="o">=</span> \
                        <span class="n">mole_fraction_funcs</span><span class="p">[(</span><span class="n">phases</span><span class="p">[</span><span class="n">phase_idx</span><span class="p">],</span> <span class="n">comp</span><span class="p">)][</span><span class="mi">0</span><span class="p">](</span>
                            <span class="o">*</span><span class="n">candidate_site_fracs</span><span class="p">[</span><span class="n">var_offset</span><span class="p">:</span><span class="n">var_offset</span> <span class="o">+</span> <span class="n">phase_dof</span><span class="p">[</span><span class="n">phase_idx</span><span class="p">]])</span>
                <span class="n">var_offset</span> <span class="o">+=</span> <span class="n">phase_dof</span><span class="p">[</span><span class="n">phase_idx</span><span class="p">]</span>

            <span class="n">properties</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;solve_iterations&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">total_comp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;NP&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">][</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> \
                                   <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">driving_force</span> <span class="o">=</span> <span class="p">(</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;MU&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">]</span> <span class="o">*</span> <span class="n">total_comp</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> \
                             <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;GM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">]</span>
            <span class="n">driving_force</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">driving_force</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Chem pot progress&#39;</span><span class="p">,</span> <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;MU&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">]</span> <span class="o">-</span> <span class="n">old_chem_pots</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Energy progress&#39;</span><span class="p">,</span> <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;GM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">]</span> <span class="o">-</span> <span class="n">old_energy</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Driving force&#39;</span><span class="p">,</span> <span class="n">driving_force</span><span class="p">)</span>
            <span class="n">no_progress</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;MU&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">]</span> <span class="o">-</span> <span class="n">old_chem_pots</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.01</span>
            <span class="n">no_progress</span> <span class="o">&amp;=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;GM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">]</span> <span class="o">-</span> <span class="n">old_energy</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">MIN_SOLVE_ENERGY_PROGRESS</span>
            <span class="k">if</span> <span class="n">no_progress</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">driving_force</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">MAX_SOLVE_DRIVING_FORCE</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Driving force failed to converge: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cur_conds</span><span class="p">))</span>
                <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;MU&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;NP&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;GM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;Phase&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="n">no_progress</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No progress&#39;</span><span class="p">)</span>
                <span class="n">num_mass_bals</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cur_conds</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;X_&#39;</span><span class="p">)])</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">chemical_potentials</span> <span class="o">=</span> <span class="n">l_multipliers</span><span class="p">[</span><span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">dbf</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sublattices</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">phases</span><span class="p">]):</span>
                                                    <span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">dbf</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sublattices</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">phases</span><span class="p">])</span> <span class="o">+</span> <span class="n">num_mass_bals</span><span class="p">]</span>
                <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;MU&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">chemical_potentials</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="p">(</span><span class="ow">not</span> <span class="n">no_progress</span><span class="p">)</span> <span class="ow">and</span> <span class="n">cur_iter</span> <span class="o">==</span> <span class="n">MAX_SOLVE_ITERATIONS</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Failed to converge: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cur_conds</span><span class="p">))</span>
                <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;MU&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;NP&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;GM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;Phase&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">it</span><span class="o">.</span><span class="n">multi_index</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">it</span><span class="o">.</span><span class="n">iternext</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">properties</span>

<span class="nd">@TempfileManager</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">())</span>
<span class="k">def</span> <span class="nf">_eqcalculate</span><span class="p">(</span><span class="n">dbf</span><span class="p">,</span> <span class="n">comps</span><span class="p">,</span> <span class="n">phases</span><span class="p">,</span> <span class="n">conditions</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">tmpman</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">per_phase</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    WARNING: API/calling convention not finalized.</span>
<span class="sd">    Compute the *equilibrium value* of a property.</span>
<span class="sd">    This function differs from `calculate` in that it computes</span>
<span class="sd">    thermodynamic equilibrium instead of randomly sampling the</span>
<span class="sd">    internal degrees of freedom of a phase.</span>
<span class="sd">    Because of that, it&#39;s slower than `calculate`.</span>
<span class="sd">    This plugs in the equilibrium phase and site fractions</span>
<span class="sd">    to compute a thermodynamic property defined in a Model.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dbf : Database</span>
<span class="sd">        Thermodynamic database containing the relevant parameters.</span>
<span class="sd">    comps : list</span>
<span class="sd">        Names of components to consider in the calculation.</span>
<span class="sd">    phases : list or dict</span>
<span class="sd">        Names of phases to consider in the calculation.</span>
<span class="sd">    conditions : dict or (list of dict)</span>
<span class="sd">        StateVariables and their corresponding value.</span>
<span class="sd">    output : str</span>
<span class="sd">        Equilibrium model property (e.g., CPM, HM, etc.) to compute.</span>
<span class="sd">        This must be defined as an attribute in the Model class of each phase.</span>
<span class="sd">    tmpman : TempfileManager, optional</span>
<span class="sd">        Context manager for temporary file creation during the calculation.</span>
<span class="sd">    data : Dataset, optional</span>
<span class="sd">        Previous result of call to `equilibrium`.</span>
<span class="sd">        Should contain the equilibrium configurations at the conditions of interest.</span>
<span class="sd">        If the databases are not the same as in the original calculation,</span>
<span class="sd">        the results may be meaningless. If None, `equilibrium` will be called.</span>
<span class="sd">        Specifying this keyword argument can save the user some time if several properties</span>
<span class="sd">        need to be calculated in succession.</span>
<span class="sd">    per_phase : bool, optional</span>
<span class="sd">        If True, compute and return the property for each phase present.</span>
<span class="sd">        If False, return the total system value, weighted by the phase fractions.</span>
<span class="sd">    kwargs</span>
<span class="sd">        Passed to `calculate`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Dataset of property as a function of equilibrium conditions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">equilibrium</span><span class="p">(</span><span class="n">dbf</span><span class="p">,</span> <span class="n">comps</span><span class="p">,</span> <span class="n">phases</span><span class="p">,</span> <span class="n">conditions</span><span class="p">)</span>
    <span class="n">active_phases</span> <span class="o">=</span> <span class="n">unpack_phases</span><span class="p">(</span><span class="n">phases</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dbf</span><span class="o">.</span><span class="n">phases</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">conds</span> <span class="o">=</span> <span class="n">_adjust_conditions</span><span class="p">(</span><span class="n">conditions</span><span class="p">)</span>
    <span class="n">indep_vars</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;P&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">]</span>
    <span class="c1"># TODO: Rewrite this to use the coord dict from &#39;data&#39;</span>
    <span class="n">str_conds</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">conds</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
    <span class="n">indep_vals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">val</span><span class="p">)]</span>
                      <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">str_conds</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">indep_vars</span><span class="p">)</span>
    <span class="n">coord_dict</span> <span class="o">=</span> <span class="n">str_conds</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">components</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">comps</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;VA&#39;</span><span class="p">)]</span>
    <span class="n">coord_dict</span><span class="p">[</span><span class="s1">&#39;vertex&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">components</span><span class="p">))</span>
    <span class="n">grid_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">coord_dict</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span>
                             <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">prop_shape</span> <span class="o">=</span> <span class="n">grid_shape</span>
    <span class="n">prop_dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">str_conds</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;vertex&#39;</span><span class="p">]</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">({</span><span class="n">output</span><span class="p">:</span> <span class="p">(</span><span class="n">prop_dims</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">prop_shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">))},</span> <span class="n">coords</span><span class="o">=</span><span class="n">coord_dict</span><span class="p">)</span>
    <span class="c1"># For each phase select all conditions where that phase exists</span>
    <span class="c1"># Perform the appropriate calculation and then write the result back</span>
    <span class="k">for</span> <span class="n">phase</span> <span class="ow">in</span> <span class="n">active_phases</span><span class="p">:</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">dbf</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="n">phase</span><span class="p">]</span><span class="o">.</span><span class="n">constituents</span><span class="p">])</span>
        <span class="n">current_phase_indices</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">Phase</span><span class="o">.</span><span class="n">values</span> <span class="o">==</span> <span class="n">phase</span><span class="p">)</span>
        <span class="k">if</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">current_phase_indices</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">Y</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">current_phase_indices</span><span class="p">)][</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">dof</span><span class="p">]</span>
        <span class="n">statevar_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">current_phase_indices</span><span class="p">)[:</span><span class="nb">len</span><span class="p">(</span><span class="n">indep_vals</span><span class="p">)]</span>
        <span class="n">statevars</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">vals</span><span class="p">),</span> <span class="n">idx</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">vals</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indep_vars</span><span class="p">,</span> <span class="n">indep_vals</span><span class="p">,</span> <span class="n">statevar_indices</span><span class="p">)}</span>
        <span class="n">statevars</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">statevars</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;mode&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">statevars</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;numpy&#39;</span>
        <span class="n">calcres</span> <span class="o">=</span> <span class="n">calculate</span><span class="p">(</span><span class="n">dbf</span><span class="p">,</span> <span class="n">comps</span><span class="p">,</span> <span class="p">[</span><span class="n">phase</span><span class="p">],</span> <span class="n">output</span><span class="o">=</span><span class="n">output</span><span class="p">,</span> <span class="n">tmpman</span><span class="o">=</span><span class="n">tmpman</span><span class="p">,</span>
                            <span class="n">points</span><span class="o">=</span><span class="n">points</span><span class="p">,</span> <span class="n">broadcast</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">statevars</span><span class="p">)</span>
        <span class="n">result</span><span class="p">[</span><span class="n">output</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">current_phase_indices</span><span class="p">)]</span> <span class="o">=</span> <span class="n">calcres</span><span class="p">[</span><span class="n">output</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">per_phase</span><span class="p">:</span>
        <span class="n">result</span><span class="p">[</span><span class="n">output</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">output</span><span class="p">]</span> <span class="o">*</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;NP&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;vertex&#39;</span><span class="p">,</span> <span class="n">skipna</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;Phase&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;Phase&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">result</span><span class="p">[</span><span class="s1">&#39;NP&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;NP&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="nd">@TempfileManager</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">())</span>
<div class="viewcode-block" id="equilibrium"><a class="viewcode-back" href="../../../api/pycalphad.core.html#pycalphad.core.equilibrium.equilibrium">[docs]</a><span class="k">def</span> <span class="nf">equilibrium</span><span class="p">(</span><span class="n">dbf</span><span class="p">,</span> <span class="n">comps</span><span class="p">,</span> <span class="n">phases</span><span class="p">,</span> <span class="n">conditions</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">pbar</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">broadcast</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">calc_opts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">nprocs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tmpman</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">return_grids</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the equilibrium state of a system containing the specified</span>
<span class="sd">    components and phases, under the specified conditions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dbf : Database</span>
<span class="sd">        Thermodynamic database containing the relevant parameters.</span>
<span class="sd">    comps : list</span>
<span class="sd">        Names of components to consider in the calculation.</span>
<span class="sd">    phases : list or dict</span>
<span class="sd">        Names of phases to consider in the calculation.</span>
<span class="sd">    conditions : dict or (list of dict)</span>
<span class="sd">        StateVariables and their corresponding value.</span>
<span class="sd">    output : str or list of str, optional</span>
<span class="sd">        Additional equilibrium model properties (e.g., CPM, HM, etc.) to compute.</span>
<span class="sd">        These must be defined as attributes in the Model class of each phase.</span>
<span class="sd">    model : Model, a dict of phase names to Model, or a seq of both, optional</span>
<span class="sd">        Model class to use for each phase.</span>
<span class="sd">    verbose : bool, optional</span>
<span class="sd">        Print details of calculations. Useful for debugging.</span>
<span class="sd">    pbar : bool, optional</span>
<span class="sd">        Show a progress bar.</span>
<span class="sd">    broadcast : bool</span>
<span class="sd">        If True, broadcast conditions against each other. This will compute all combinations.</span>
<span class="sd">        If False, each condition should be an equal-length list (or single-valued).</span>
<span class="sd">        Disabling broadcasting is useful for calculating equilibrium at selected conditions,</span>
<span class="sd">        when those conditions don&#39;t comprise a grid.</span>
<span class="sd">    calc_opts : dict, optional</span>
<span class="sd">        Keyword arguments to pass to `calculate`, the energy/property calculation routine.</span>
<span class="sd">    nprocs : int, optional</span>
<span class="sd">        Number of worker processes to create. By default, equal to the number of CPUs.</span>
<span class="sd">    tmpman : TempfileManager, optional</span>
<span class="sd">        Context manager for temporary file creation during the calculation.</span>
<span class="sd">    return_grids : bool, optional</span>
<span class="sd">        If True, return a tuple of (equilibrium result, grids), where grids is a list of</span>
<span class="sd">        Datasets containing the global point set at each hull iteration.</span>
<span class="sd">        Mainly useful for teaching and debugging.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Structured equilibrium calculation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    None yet.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">broadcast</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Broadcasting cannot yet be disabled&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nprocs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">nprocs</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid nprocs value: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nprocs</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">nprocs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nprocs</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">tmpman</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No tempfile context manager specified for calculation&#39;</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">pycalphad</span> <span class="k">import</span> <span class="n">__version__</span> <span class="k">as</span> <span class="n">pycalphad_version</span>
    <span class="n">active_phases</span> <span class="o">=</span> <span class="n">unpack_phases</span><span class="p">(</span><span class="n">phases</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dbf</span><span class="o">.</span><span class="n">phases</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">comps</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">comps</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">comps</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">dbf</span><span class="o">.</span><span class="n">elements</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">EquilibriumError</span><span class="p">(</span><span class="s1">&#39;Components not found in database: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">comps</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">dbf</span><span class="o">.</span><span class="n">elements</span><span class="p">))))</span>
    <span class="n">indep_vars</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;P&#39;</span><span class="p">]</span>
    <span class="n">calc_opts</span> <span class="o">=</span> <span class="n">calc_opts</span> <span class="k">if</span> <span class="n">calc_opts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">model</span> <span class="k">if</span> <span class="n">model</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">Model</span>
    <span class="n">phase_records</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">callable_dict</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;callables&#39;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">())</span>
    <span class="n">grad_callable_dict</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;grad_callables&#39;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">())</span>
    <span class="n">hess_callable_dict</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;hess_callables&#39;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">())</span>
    <span class="n">maximum_internal_dof</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># Modify conditions values to be within numerical limits, e.g., X(AL)=0</span>
    <span class="c1"># Also wrap single-valued conditions with lists</span>
    <span class="n">conds</span> <span class="o">=</span> <span class="n">_adjust_conditions</span><span class="p">(</span><span class="n">conditions</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">cond</span> <span class="ow">in</span> <span class="n">conds</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">Composition</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">ChemicalPotential</span><span class="p">))</span> <span class="ow">and</span> <span class="n">cond</span><span class="o">.</span><span class="n">species</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">comps</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ConditionError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> refers to non-existent component&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cond</span><span class="p">))</span>
    <span class="n">str_conds</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">((</span><span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">),</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">conds</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
    <span class="n">num_calcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">str_conds</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
    <span class="k">if</span> <span class="n">num_calcs</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
        <span class="n">build_functions</span> <span class="o">=</span> <span class="n">compiled_build_functions</span>
        <span class="n">backend_mode</span> <span class="o">=</span> <span class="s1">&#39;compiled&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">build_functions</span> <span class="o">=</span> <span class="n">interpreted_build_functions</span>
        <span class="n">backend_mode</span> <span class="o">=</span> <span class="s1">&#39;interpreted&#39;</span>
    <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;_backend&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">backend_mode</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;_backend&#39;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">backend_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;compiled&#39;</span><span class="p">:</span> <span class="s1">&#39;Compiled (ufuncify)&#39;</span><span class="p">,</span> <span class="s1">&#39;interpreted&#39;</span><span class="p">:</span> <span class="s1">&#39;Interpreted (autograd)&#39;</span><span class="p">}</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Calculation Backend: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">backend_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">backend_mode</span><span class="p">,</span> <span class="s1">&#39;Custom&#39;</span><span class="p">)))</span>
    <span class="n">indep_vals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">val</span><span class="p">)]</span>
                      <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">str_conds</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">indep_vars</span><span class="p">)</span>
    <span class="n">components</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">comps</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;VA&#39;</span><span class="p">)]</span>
    <span class="c1"># Construct models for each phase; prioritize user models</span>
    <span class="n">models</span> <span class="o">=</span> <span class="n">unpack_kwarg</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">default_arg</span><span class="o">=</span><span class="n">Model</span><span class="p">)</span>
    <span class="c1"># for debugging</span>
    <span class="k">if</span> <span class="n">return_grids</span><span class="p">:</span>
        <span class="n">intermediate_grids</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Components:&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">comps</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Phases:&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">progressbar</span><span class="p">(</span><span class="n">active_phases</span><span class="p">,</span> <span class="n">desc</span><span class="o">=</span><span class="s1">&#39;Initialize (1/3)&#39;</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;phase&#39;</span><span class="p">,</span> <span class="n">disable</span><span class="o">=</span><span class="ow">not</span> <span class="n">pbar</span><span class="p">):</span>
        <span class="n">mod</span> <span class="o">=</span> <span class="n">models</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mod</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
            <span class="n">models</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">mod</span> <span class="o">=</span> <span class="n">mod</span><span class="p">(</span><span class="n">dbf</span><span class="p">,</span> <span class="n">comps</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">mod</span><span class="o">.</span><span class="n">energy</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">StateVariable</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">({</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">conditions</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">P</span><span class="p">]}),</span> <span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
        <span class="n">site_fracs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">mod</span><span class="o">.</span><span class="n">energy</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">SiteFraction</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="nb">str</span><span class="p">)</span>
        <span class="n">maximum_internal_dof</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maximum_internal_dof</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">site_fracs</span><span class="p">))</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">models</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">energy</span>
        <span class="n">undefs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)</span> <span class="o">-</span> <span class="n">out</span><span class="o">.</span><span class="n">atoms</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">StateVariable</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">undef</span> <span class="ow">in</span> <span class="n">undefs</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">xreplace</span><span class="p">({</span><span class="n">undef</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="mi">0</span><span class="p">)})</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">callable_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span> <span class="ow">or</span> <span class="ow">not</span> <span class="p">(</span><span class="n">grad_callable_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="kc">False</span><span class="p">))</span> \
            <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">hess_callable_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="kc">False</span><span class="p">)):</span>
            <span class="n">cf</span><span class="p">,</span> <span class="n">gf</span><span class="p">,</span> <span class="n">hf</span> <span class="o">=</span> <span class="n">build_functions</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">P</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="p">]</span> <span class="o">+</span> <span class="n">site_fracs</span><span class="p">,</span> <span class="n">tmpman</span><span class="o">=</span><span class="n">tmpman</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">callable_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">callable_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">cf</span>
            <span class="k">if</span> <span class="n">grad_callable_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">grad_callable_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">gf</span>
            <span class="k">if</span> <span class="n">hess_callable_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">hess_callable_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">hf</span>

        <span class="c1"># Adjust gradient by the approximate chemical potentials</span>
        <span class="n">hyperplane</span> <span class="o">=</span> <span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">MU</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">mole_fraction</span><span class="p">(</span><span class="n">dbf</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">comps</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                           <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">comps</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="s1">&#39;VA&#39;</span><span class="p">])</span>
        <span class="n">plane_obj</span><span class="p">,</span> <span class="n">plane_grad</span><span class="p">,</span> <span class="n">plane_hess</span> <span class="o">=</span> <span class="n">build_functions</span><span class="p">(</span><span class="n">hyperplane</span><span class="p">,</span>
                                                            <span class="p">[</span><span class="n">v</span><span class="o">.</span><span class="n">MU</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">comps</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="s1">&#39;VA&#39;</span><span class="p">]</span><span class="o">+</span><span class="n">site_fracs</span><span class="p">,</span>
                                                            <span class="n">tmpman</span><span class="o">=</span><span class="n">tmpman</span><span class="p">)</span>

        <span class="n">mass_obj</span><span class="p">,</span> <span class="n">mass_grad</span><span class="p">,</span> <span class="n">mass_hess</span> <span class="o">=</span> <span class="n">build_functions</span><span class="p">(</span><span class="n">Add</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">mole_fraction</span><span class="p">(</span><span class="n">dbf</span><span class="o">.</span><span class="n">phases</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">comps</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
                                                               <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">comps</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="s1">&#39;VA&#39;</span><span class="p">]),</span> <span class="n">site_fracs</span><span class="p">,</span>
                                                         <span class="n">tmpman</span><span class="o">=</span><span class="n">tmpman</span><span class="p">)</span>
        <span class="n">phase_records</span><span class="p">[</span><span class="n">name</span><span class="o">.</span><span class="n">upper</span><span class="p">()]</span> <span class="o">=</span> <span class="n">PhaseRecord</span><span class="p">(</span><span class="n">variables</span><span class="o">=</span><span class="n">variables</span><span class="p">,</span>
                                                  <span class="n">grad</span><span class="o">=</span><span class="n">grad_callable_dict</span><span class="p">[</span><span class="n">name</span><span class="p">],</span>
                                                  <span class="n">hess</span><span class="o">=</span><span class="n">hess_callable_dict</span><span class="p">[</span><span class="n">name</span><span class="p">],</span>
                                                  <span class="n">plane_grad</span><span class="o">=</span><span class="n">plane_grad</span><span class="p">,</span>
                                                  <span class="n">plane_hess</span><span class="o">=</span><span class="n">plane_hess</span><span class="p">,</span>
                                                  <span class="n">mass_obj</span><span class="o">=</span><span class="n">mass_obj</span><span class="p">,</span>
                                                  <span class="n">mass_grad</span><span class="o">=</span><span class="n">mass_grad</span><span class="p">,</span>
                                                  <span class="n">mass_hess</span><span class="o">=</span><span class="n">mass_hess</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[done]&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># &#39;calculate&#39; accepts conditions through its keyword arguments</span>
    <span class="n">grid_opts</span> <span class="o">=</span> <span class="n">calc_opts</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">grid_opts</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">key</span><span class="p">:</span> <span class="n">value</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">str_conds</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">indep_vars</span><span class="p">})</span>
    <span class="k">if</span> <span class="s1">&#39;pdens&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">grid_opts</span><span class="p">:</span>
        <span class="n">grid_opts</span><span class="p">[</span><span class="s1">&#39;pdens&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">300</span>

    <span class="n">coord_dict</span> <span class="o">=</span> <span class="n">str_conds</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">coord_dict</span><span class="p">[</span><span class="s1">&#39;vertex&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">components</span><span class="p">))</span>
    <span class="n">grid_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">coord_dict</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span>
                             <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">coord_dict</span><span class="p">[</span><span class="s1">&#39;component&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">components</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Computing initial grid&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">)</span>

    <span class="n">grid</span> <span class="o">=</span> <span class="n">calculate</span><span class="p">(</span><span class="n">dbf</span><span class="p">,</span> <span class="n">comps</span><span class="p">,</span> <span class="n">active_phases</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;GM&#39;</span><span class="p">,</span> <span class="n">tmpman</span><span class="o">=</span><span class="n">tmpman</span><span class="p">,</span>
                     <span class="n">model</span><span class="o">=</span><span class="n">models</span><span class="p">,</span> <span class="n">callables</span><span class="o">=</span><span class="n">callable_dict</span><span class="p">,</span> <span class="n">fake_points</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">grid_opts</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">return_grids</span><span class="p">:</span>
        <span class="n">intermediate_grids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;[</span><span class="si">{0}</span><span class="s1"> points, </span><span class="si">{1}</span><span class="s1">]&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">points</span><span class="p">),</span> <span class="n">sizeof_fmt</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">nbytes</span><span class="p">)),</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="n">properties</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">({</span><span class="s1">&#39;NP&#39;</span><span class="p">:</span> <span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">str_conds</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;vertex&#39;</span><span class="p">],</span>
                                 <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">grid_shape</span><span class="p">)),</span>
                          <span class="s1">&#39;GM&#39;</span><span class="p">:</span> <span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">str_conds</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
                                 <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">grid_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])),</span>
                          <span class="s1">&#39;MU&#39;</span><span class="p">:</span> <span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">str_conds</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;component&#39;</span><span class="p">],</span>
                                 <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">grid_shape</span><span class="p">)),</span>
                          <span class="s1">&#39;points&#39;</span><span class="p">:</span> <span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">str_conds</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;vertex&#39;</span><span class="p">],</span>
                                     <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">grid_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">))</span>
                          <span class="p">},</span>
                          <span class="n">coords</span><span class="o">=</span><span class="n">coord_dict</span><span class="p">,</span>
                          <span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;hull_iterations&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;solve_iterations&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                                 <span class="s1">&#39;engine&#39;</span><span class="p">:</span> <span class="s1">&#39;pycalphad </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">pycalphad_version</span><span class="p">},</span>
                         <span class="p">)</span>
    <span class="c1"># Make sure all the verbose output appears to the user</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Refining equilibrium&#39;</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
    <span class="c1"># One last call to ensure &#39;properties&#39; and &#39;grid&#39; are consistent with one another</span>
    <span class="n">lower_convex_hull</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">properties</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span>
    <span class="n">indexer</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">vals</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indep_vals</span><span class="p">):</span>
        <span class="n">indexer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)[</span><span class="n">idx</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[:]</span> <span class="o">+</span> \
                                                          <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">conds</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">-</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,)])</span>
    <span class="n">indexer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;points&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
    <span class="n">indexer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)[(</span><span class="nb">len</span><span class="p">(</span><span class="n">conds</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[:]])</span>
    <span class="n">ravelled_X_view</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">indexer</span><span class="p">)]</span>
    <span class="n">indexer</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)[(</span><span class="nb">len</span><span class="p">(</span><span class="n">conds</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[:]]</span>
    <span class="n">ravelled_Y_view</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">indexer</span><span class="p">)]</span>
    <span class="n">indexer</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">vals</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indep_vals</span><span class="p">):</span>
        <span class="n">indexer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)[</span><span class="n">idx</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[:]</span> <span class="o">+</span> \
                                                          <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">conds</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="o">-</span><span class="n">idx</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,)])</span>
    <span class="n">indexer</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;points&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    <span class="n">ravelled_Phase_view</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[</span><span class="s1">&#39;Phase&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">indexer</span><span class="p">)]</span>
    <span class="c1"># Copy final point values from the grid and drop the index array</span>
    <span class="c1"># For some reason direct construction doesn&#39;t work. We have to create empty and then assign.</span>
    <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">DataArray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">ravelled_X_view</span><span class="p">),</span>
                                <span class="n">dims</span><span class="o">=</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;points&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;component&#39;</span><span class="p">,))</span>
    <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;X&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">ravelled_X_view</span>
    <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">DataArray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">ravelled_Y_view</span><span class="p">),</span>
                                <span class="n">dims</span><span class="o">=</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;points&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;internal_dof&#39;</span><span class="p">,))</span>
    <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;Y&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">ravelled_Y_view</span>
    <span class="c1"># TODO: What about invariant reactions? We should perform a final driving force calculation here.</span>
    <span class="c1"># We can handle that in the same post-processing step where we identify single-phase regions.</span>
    <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;Phase&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">DataArray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">ravelled_Phase_view</span><span class="p">),</span>
                                    <span class="n">dims</span><span class="o">=</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;points&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span><span class="p">)</span>
    <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;Phase&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">ravelled_Phase_view</span>
    <span class="k">del</span> <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;points&#39;</span><span class="p">]</span>
    <span class="n">num_conds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;GM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">values</span><span class="p">()])</span>
    <span class="n">conditions_per_chunk_per_axis</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">nprocs</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">num_conds</span><span class="p">,</span> <span class="n">nprocs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nprocs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Generate slices of &#39;properties&#39;</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">[</span><span class="s1">&#39;GM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">idx_arr</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)))</span>
            <span class="n">num_chunks</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span><span class="o">/</span><span class="n">conditions_per_chunk_per_axis</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">num_chunks</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">cond_slices</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">idx_arr</span><span class="p">),</span> <span class="n">num_chunks</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cond_slices</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx_arr</span><span class="p">]</span>
            <span class="n">slices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cond_slices</span><span class="p">)</span>
        <span class="n">chunk_dims</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">slc</span><span class="p">)</span> <span class="k">for</span> <span class="n">slc</span> <span class="ow">in</span> <span class="n">slices</span><span class="p">]</span>
        <span class="n">chunk_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">chunk_dims</span><span class="p">)),</span> <span class="n">chunk_dims</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">chunk_grid</span><span class="p">:</span>
            <span class="n">prop_slice</span> <span class="o">=</span> <span class="n">properties</span><span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;GM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">sl</span><span class="p">)[</span><span class="n">ch</span><span class="p">]</span>
                                                                              <span class="k">for</span> <span class="n">ch</span><span class="p">,</span> <span class="n">sl</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">chunk</span><span class="p">,</span> <span class="n">slices</span><span class="p">)]))]</span>
            <span class="n">job</span> <span class="o">=</span> <span class="n">dask</span><span class="o">.</span><span class="n">delayed</span><span class="p">(</span><span class="n">_solve_eq_at_conditions</span><span class="p">,</span> <span class="n">pure</span><span class="o">=</span><span class="kc">True</span><span class="p">)(</span><span class="n">dbf</span><span class="p">,</span> <span class="n">comps</span><span class="p">,</span> <span class="n">prop_slice</span><span class="p">,</span>
                                                                   <span class="n">phase_records</span><span class="p">,</span> <span class="n">callable_dict</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
            <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">job</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">dask</span><span class="o">.</span><span class="n">compute</span><span class="p">(</span><span class="o">*</span><span class="n">res</span><span class="p">,</span> <span class="n">get</span><span class="o">=</span><span class="n">dask</span><span class="o">.</span><span class="n">multiprocessing</span><span class="o">.</span><span class="n">get</span><span class="p">)</span>
        <span class="c1"># Merge back together slices of &#39;properties&#39;</span>
        <span class="k">for</span> <span class="n">prop_slice</span><span class="p">,</span> <span class="n">prop_arr</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">chunk_grid</span><span class="p">,</span> <span class="n">results</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prop_arr</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Error: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prop_arr</span><span class="p">))</span>
                <span class="k">continue</span>
            <span class="n">all_coords</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">properties</span><span class="p">[</span><span class="s1">&#39;GM&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">sl</span><span class="p">)[</span><span class="n">ch</span><span class="p">]</span>
                                                                   <span class="k">for</span> <span class="n">ch</span><span class="p">,</span> <span class="n">sl</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">prop_slice</span><span class="p">,</span> <span class="n">slices</span><span class="p">)]))</span>
            <span class="k">for</span> <span class="n">dv</span> <span class="ow">in</span> <span class="n">properties</span><span class="o">.</span><span class="n">data_vars</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="c1"># Have to be very careful with how we assign to &#39;properties&#39; here</span>
                <span class="c1"># We may accidentally assign to a copy unless we index the data variable first</span>
                <span class="n">dv_coords</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">all_coords</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">[</span><span class="n">dv</span><span class="p">]</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
                <span class="n">properties</span><span class="p">[</span><span class="n">dv</span><span class="p">][</span><span class="n">dv_coords</span><span class="p">]</span> <span class="o">=</span> <span class="n">prop_arr</span><span class="p">[</span><span class="n">dv</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Single-process job; don&#39;t create child processes</span>
        <span class="n">properties</span> <span class="o">=</span> <span class="n">_solve_eq_at_conditions</span><span class="p">(</span><span class="n">dbf</span><span class="p">,</span> <span class="n">comps</span><span class="p">,</span> <span class="n">properties</span><span class="p">,</span> <span class="n">phase_records</span><span class="p">,</span> <span class="n">callable_dict</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>

    <span class="c1"># Compute equilibrium values of any additional user-specified properties</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">output</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">set</span><span class="p">))</span> <span class="k">else</span> <span class="p">[</span><span class="n">output</span><span class="p">]</span>
    <span class="c1"># We already computed these properties so don&#39;t recompute them</span>
    <span class="n">output</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">output</span><span class="p">)</span> <span class="o">-</span> <span class="p">{</span><span class="s1">&#39;GM&#39;</span><span class="p">,</span> <span class="s1">&#39;MU&#39;</span><span class="p">})</span>
    <span class="k">for</span> <span class="n">out</span> <span class="ow">in</span> <span class="n">output</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="c1"># TODO: How do we know if a specified property should be per_phase or not?</span>
        <span class="c1"># For now, we make a best guess</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;degree_of_ordering&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;DOO&#39;</span><span class="p">):</span>
            <span class="n">per_phase</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">per_phase</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">properties</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">_eqcalculate</span><span class="p">(</span><span class="n">dbf</span><span class="p">,</span> <span class="n">comps</span><span class="p">,</span> <span class="n">active_phases</span><span class="p">,</span> <span class="n">conditions</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span>
                                      <span class="n">data</span><span class="o">=</span><span class="n">properties</span><span class="p">,</span> <span class="n">per_phase</span><span class="o">=</span><span class="n">per_phase</span><span class="p">,</span> <span class="o">**</span><span class="n">calc_opts</span><span class="p">),</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">compat</span><span class="o">=</span><span class="s1">&#39;equals&#39;</span><span class="p">)</span>
    <span class="n">properties</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;created&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">utcnow</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">return_grids</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">properties</span><span class="p">,</span> <span class="n">intermediate_grids</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">properties</span></div>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, pycalphad Development Team.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.4+19.g9b7798b',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>